// 动态规划

// 本题给定 n 堆石头，每次合并连续的k堆，合并的成本是这 k 堆石头的总数，问最终把所有石头合并为一堆的最低成本。
// 我们从最简单的情况入手，当 k 等于 2 时，每次选择相邻的两堆进行合并。在最后一次合并之前，n 堆石头经过若干次合并变为两堆石头，假设 [0,p] 合并为一堆，[p+1,n−1] 合并为一堆，然后我们再将这两堆合并成新的一堆，这次操作的成本是 n 堆石头的总数。
// 注意到，将 [0,p] 合并为一堆以及将 [p+1,n−1] 合并为一堆都是问题规模较小的子问题，可以递归求解。我们设 d[l][r] 是 [l,r] 合并为一堆石头的最低成本，然后用记忆化搜索或者递推的方式来求解。我们用初态、转移方程和目标来描述求解过程：
  // 1.初态：对于所有的 d[i][i]，初始化为 0，其他状态初始值设置为正无穷。
  // 2.转移方程：d[l][r]=min{d[l][p]+d[p+1][r]}，其中 l≤p<r。
  // 3.目标：d[0][n−1]。
// 以上就是 k=2 时的求解思路，在这种情况下，该题目为经典的区间动态规划问题。

// 接下来我们思考当 k 为其他数字时如何求解。
// n 大于 1 时若想将 n 堆石子合并为 1 堆，我们首先准备好不同的 k 堆，因此可以用 d[l][r][t] 描述这个状态，表示将 [l,r] 合并为 t (1≤t≤k) 堆的最低成本。与 k=2 时的思考方式一致，我们考虑一个分界点 p (l≤p<r)，令 [l,p] 合并为 1 堆，再令 [p+1,r] 合并为 t−1 堆，这样就可以将问题拆分为两个子问题进行求解。
  // 1.初态：对于所有的 d[i][i][1]，初始化为 0，其他状态设置为正无穷。
  // 2.转移方程：
  //   1.当 t=1时，d[l][r][t]=d[l][r][k]+sum[l][r]，其中 sum[l][r]是本次合并的成本，区间内石头的总数。
  //   2.否则，d[l][r][t]=min{d[l][p][1]+d[p+1][r][t−1]}，其中 l≤p<r。
  // 3.目标：d[0][n−1][1]。
// 在转移过程中，我们只考虑了将 [l,p] 合并为 1 堆的子问题，倘若将 d[l][r][t] 拆分为 d[l][p][2]+d[p+1][r][t−2] 是否可行？答案是可行的，但是会重复求解。递归求解 d[l][p][2] 时，我们会再枚举一个 p1(l≤p1<p)。所以我们只需要考虑拆分左边区间 [l,p] 合并为一堆的子问题即可，可以不重不漏的遍历所有子问题。
// 为什么只考虑 t≤k 的情况？因为我们在状态转移时不需要这样的子状态，如果t>k，我们希望子问题能够把它合并到小于 k 堆的状态。
// 那么什么情况会无解？每一次合并将 k 堆石头变为 1 堆，堆数减少 k−1，如果合并若干次要使得 n 堆变为 1 堆，就需要 n−1 是 k−1 的倍数。只要满足这个条件，d[0][n−1][k] 一定有解，否则无解。在求解过程中，一些中间状态也有可能无解，我们可以直接用正无穷这个数字来表征它无解。
// 最后来看一下是否有优化点，在拆分子问题 d[l][p][1] 时，我们提前知道了当p−l 是 k−1 的倍数时才会有解，因此从 l 开始枚举 p，每次递增 k−1。这样可以避免很多无解状态的枚举。

const INF = 0x3f3f3f3f
var mergeStones = function(stones, k) {
    const n = stones.length
    if ((n - 1) % (k - 1) !== 0) return -1
    const d = new Array(n).fill(0).map(() => new Array(n).fill(0).map(() => new Array(k + 1).fill(-1)))
    const sum = new Array(n).fill(0)
    for(let i = 0, s = 0; i < n; i++) {
        d[i][i][1] = 0
        s += stones[i]
        sum[i] = s
    }
    const get = (l, r, t) => {
        if (d[l][r][t] !== -1) return d[l][r][t]
        if (t > r - l + 1) return INF
        if (t === 1) {
            const res = get(l, r, k)
            if (res === INF) return d[l][r][t] = INF
            return d[l][r][t] = res + (sum[r] - (l === 0 ? 0 : sum[l - 1]))
        }
        let val = INF
        for (let p = l; p < r; p += (k - 1)) {
            val = Math.min(val, get(l, p, 1) + get(p + 1, r, t - 1))
        }
        return d[l][r][t] = val
    }
    const res = get(0, n - 1, 1)
    return res
};

// 时间复杂度：O(n^3k)，其中 n 是 stones 的长度
// 空间复杂度：O(n^2k)，其中 n 是 stones 的长度